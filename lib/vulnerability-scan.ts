// ===== DEPENDENCY VULNERABILITY SCANNING =====
// Integration with Snyk and npm audit for vulnerability detection.

export interface Vulnerability {
  id: string;
  title: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  package: string;
  version: string;
  fixedIn?: string;
  description: string;
  cvss?: number;
  cwe?: string[];
  exploitMaturity?: string;
}

export interface AuditResult {
  vulnerabilities: Vulnerability[];
  metadata: {
    totalDependencies: number;
    vulnerablePackages: number;
    scanDate: Date;
    scanDuration: number;
  };
}

/**
 * Parse npm audit JSON output.
 */
export function parseNpmAudit(auditJson: string): AuditResult {
  try {
    const audit = JSON.parse(auditJson);
    const vulnerabilities: Vulnerability[] = [];
    
    for (const [, advisory] of Object.entries(audit.advisories || {})) {
      const adv = advisory as {
        id: number;
        title: string;
        severity: string;
        module_name: string;
        vulnerable_versions: string;
        patched_versions: string;
        overview: string;
        cves: string[];
        cwe: string[];
      };
      
      vulnerabilities.push({
        id: `npm-${adv.id}`,
        title: adv.title,
        severity: adv.severity as Vulnerability['severity'],
        package: adv.module_name,
        version: adv.vulnerable_versions,
        fixedIn: adv.patched_versions !== '<0.0.0' ? adv.patched_versions : undefined,
        description: adv.overview,
        cwe: adv.cwe,
      });
    }
    
    return {
      vulnerabilities,
      metadata: {
        totalDependencies: audit.metadata?.totalDependencies || 0,
        vulnerablePackages: vulnerabilities.length,
        scanDate: new Date(),
        scanDuration: 0,
      },
    };
  } catch {
    return {
      vulnerabilities: [],
      metadata: {
        totalDependencies: 0,
        vulnerablePackages: 0,
        scanDate: new Date(),
        scanDuration: 0,
      },
    };
  }
}

/**
 * Parse Snyk JSON output.
 */
export function parseSnykOutput(snykJson: string): AuditResult {
  try {
    const snyk = JSON.parse(snykJson);
    const vulnerabilities: Vulnerability[] = [];
    
    for (const vuln of snyk.vulnerabilities || []) {
      vulnerabilities.push({
        id: vuln.id,
        title: vuln.title,
        severity: vuln.severity,
        package: vuln.packageName,
        version: vuln.version,
        fixedIn: vuln.fixedIn?.[0],
        description: vuln.description,
        cvss: vuln.cvssScore,
        cwe: vuln.identifiers?.CWE,
        exploitMaturity: vuln.exploit,
      });
    }
    
    return {
      vulnerabilities,
      metadata: {
        totalDependencies: snyk.dependencyCount || 0,
        vulnerablePackages: vulnerabilities.length,
        scanDate: new Date(),
        scanDuration: 0,
      },
    };
  } catch {
    return {
      vulnerabilities: [],
      metadata: {
        totalDependencies: 0,
        vulnerablePackages: 0,
        scanDate: new Date(),
        scanDuration: 0,
      },
    };
  }
}

/**
 * Filter vulnerabilities by severity.
 */
export function filterBySeverity(
  vulns: Vulnerability[],
  minSeverity: 'low' | 'medium' | 'high' | 'critical'
): Vulnerability[] {
  const order = ['low', 'medium', 'high', 'critical'];
  const minIndex = order.indexOf(minSeverity);
  return vulns.filter(v => order.indexOf(v.severity) >= minIndex);
}

/**
 * Get remediation priority.
 */
export function getRemediationPriority(vuln: Vulnerability): number {
  const severityScore = { critical: 100, high: 75, medium: 50, low: 25 };
  const hasfix = vuln.fixedIn ? 10 : 0;
  const exploitScore = vuln.exploitMaturity === 'Proof of Concept' ? 20 : 
                       vuln.exploitMaturity === 'Functional' ? 40 : 0;
  
  return severityScore[vuln.severity] + hasfix + exploitScore;
}

/**
 * Generate vulnerability report.
 */
export function generateVulnReport(result: AuditResult): string {
  const sorted = [...result.vulnerabilities].sort(
    (a, b) => getRemediationPriority(b) - getRemediationPriority(a)
  );
  
  const bySeverity = {
    critical: sorted.filter(v => v.severity === 'critical'),
    high: sorted.filter(v => v.severity === 'high'),
    medium: sorted.filter(v => v.severity === 'medium'),
    low: sorted.filter(v => v.severity === 'low'),
  };
  
  return `
# Dependency Vulnerability Report

**Scan Date**: ${result.metadata.scanDate.toISOString()}
**Total Dependencies**: ${result.metadata.totalDependencies}
**Vulnerable Packages**: ${result.metadata.vulnerablePackages}

## Summary

| Severity | Count |
|----------|-------|
| üî¥ Critical | ${bySeverity.critical.length} |
| üü† High | ${bySeverity.high.length} |
| üü° Medium | ${bySeverity.medium.length} |
| üü¢ Low | ${bySeverity.low.length} |

## Critical & High Vulnerabilities

${[...bySeverity.critical, ...bySeverity.high].map(v => `
### ${v.title}
- **Package**: ${v.package}@${v.version}
- **Severity**: ${v.severity.toUpperCase()}
- **Fixed In**: ${v.fixedIn || 'No fix available'}
- **ID**: ${v.id}
`).join('') || 'None found!'}

## Recommended Actions

${bySeverity.critical.length > 0 ? '‚ö†Ô∏è **URGENT**: Address critical vulnerabilities immediately\n' : ''}
${bySeverity.high.length > 0 ? '‚ö†Ô∏è Address high severity issues within 1 week\n' : ''}
${result.metadata.vulnerablePackages === 0 ? '‚úÖ No vulnerabilities found!' : ''}
`.trim();
}

/**
 * Check if a package should be ignored (false positive, dev only, etc).
 */
export function shouldIgnoreVuln(
  vuln: Vulnerability,
  ignorePatterns: { packages?: string[]; ids?: string[] } = {}
): boolean {
  if (ignorePatterns.packages?.includes(vuln.package)) return true;
  if (ignorePatterns.ids?.includes(vuln.id)) return true;
  return false;
}
